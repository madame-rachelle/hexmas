Struct marifx_gradingvars
{
	Vector3 grademul, gradepow, gradecol;
	float gradecolfact, gradesatmul, gradesatpow, gradevalmul, gradevalpow;
};

Class mkGradingHandler : EventHandler
{
	// color grading (with transitions)
	double gspeed, gphase;
	bool genabled;
	marifx_gradingvars gvars, gvars_in, gvars_out;

	static void GradingTransition( Actor activator, int preset, double speed = 1.0, bool local = false )
	{
		let hnd = mkGradingHandler(EventHandler.Find("mkGradingHandler"));
		if ( !hnd ) return;
		if ( local && activator && (activator.player != players[consoleplayer]) ) return;
		switch ( preset )
		{
		case 0:
			// outdoor preset
			hnd.gvars_out.grademul = (0.99,1.03,1.09);
			hnd.gvars_out.gradepow = (1.01,1.03,0.87);
			hnd.gvars_out.gradecol = (-0.46,-0.31,-0.82);
			hnd.gvars_out.gradecolfact = -0.18;
			hnd.gvars_out.gradesatmul = 0.88;
			hnd.gvars_out.gradesatpow = 1.31;
			hnd.gvars_out.gradevalmul = 0.91;
			hnd.gvars_out.gradevalpow = 1.38;
			break;
		case 1:
			// indoor preset
			hnd.gvars_out.grademul = (1.02,1.11,0.96);
			hnd.gvars_out.gradepow = (1.09,1.03,0.94);
			hnd.gvars_out.gradecol = (-0.11,-0.69,-0.33);
			hnd.gvars_out.gradecolfact = -0.24;
			hnd.gvars_out.gradesatmul = 0.78;
			hnd.gvars_out.gradesatpow = 1.22;
			hnd.gvars_out.gradevalmul = 1.07;
			hnd.gvars_out.gradevalpow = 1.25;
			break;
		case 2:
			// deep preset
			hnd.gvars_out.grademul = (0.91,1.06,0.93);
			hnd.gvars_out.gradepow = (1.02,0.88,1.09);
			hnd.gvars_out.gradecol = (-0.24,-0.43,-0.19);
			hnd.gvars_out.gradecolfact = -0.22;
			hnd.gvars_out.gradesatmul = 0.93;
			hnd.gvars_out.gradesatpow = 1.13;
			hnd.gvars_out.gradevalmul = 1.08;
			hnd.gvars_out.gradevalpow = 1.51;
			break;
		}
		hnd.genabled = true;
		hnd.gphase = 0;
		hnd.gspeed = speed/Thinker.TICRATE;
		if ( speed <= 0 )
		{
			hnd.gspeed = 0;
			hnd.gvars.grademul = hnd.gvars_out.grademul;
			hnd.gvars.gradepow = hnd.gvars_out.gradepow;
			hnd.gvars.gradecol = hnd.gvars_out.gradecol;
			hnd.gvars.gradecolfact = hnd.gvars_out.gradecolfact;
			hnd.gvars.gradesatmul = hnd.gvars_out.gradesatmul;
			hnd.gvars.gradesatpow = hnd.gvars_out.gradesatpow;
			hnd.gvars.gradevalmul = hnd.gvars_out.gradevalmul;
			hnd.gvars.gradevalpow = hnd.gvars_out.gradevalpow;
		}
		hnd.gvars_in.grademul = hnd.gvars.grademul;
		hnd.gvars_in.gradepow = hnd.gvars.gradepow;
		hnd.gvars_in.gradecol = hnd.gvars.gradecol;
		hnd.gvars_in.gradecolfact = hnd.gvars.gradecolfact;
		hnd.gvars_in.gradesatmul = hnd.gvars.gradesatmul;
		hnd.gvars_in.gradesatpow = hnd.gvars.gradesatpow;
		hnd.gvars_in.gradevalmul = hnd.gvars.gradevalmul;
		hnd.gvars_in.gradevalpow = hnd.gvars.gradevalpow;
	}

	override void WorldTick()
	{
		if ( gspeed <= 0 ) return;
		gphase += gspeed;
		gphase = min(gphase,1);
		gvars.grademul = gvars_in.grademul*(1-gphase)+gvars_out.grademul*gphase;
		gvars.gradepow = gvars_in.gradepow*(1-gphase)+gvars_out.gradepow*gphase;
		gvars.gradecol = gvars_in.gradecol*(1-gphase)+gvars_out.gradecol*gphase;
		gvars.gradecolfact = gvars_in.gradecolfact*(1-gphase)+gvars_out.gradecolfact*gphase;
		gvars.gradesatmul = gvars_in.gradesatmul*(1-gphase)+gvars_out.gradesatmul*gphase;
		gvars.gradesatpow = gvars_in.gradesatpow*(1-gphase)+gvars_out.gradesatpow*gphase;
		gvars.gradevalmul = gvars_in.gradevalmul*(1-gphase)+gvars_out.gradevalmul*gphase;
		gvars.gradevalpow = gvars_in.gradevalpow*(1-gphase)+gvars_out.gradevalpow*gphase;
		if ( gphase >= 1 )
		{
			gphase = 0;
			gspeed = 0;
		}
	}

	override void WorldLoaded( WorldEvent e )
	{
		gvars.grademul = (1.0,1.0,1.0);
		gvars.gradepow = (1.0,1.0,1.0);
		gvars.gradecol = (1.0,1.0,1.0);
		gvars.gradecolfact = 0.0;
		gvars.gradesatmul = 1.0;
		gvars.gradesatpow = 1.0;
		gvars.gradevalmul = 1.0;
		gvars.gradevalpow = 1.0;
		if ( level.mapname ~== "MARISA" )
			GradingTransition(null,0,0);
	}

	override void RenderOverlay( RenderEvent e )
	{
		PlayerInfo p = players[consoleplayer];
		Shader.SetEnabled(p,"marifx_grading",genabled);
		if ( !genabled ) return;
		Shader.SetUniform3f(p,"marifx_grading","grademul",gvars.grademul);
		Shader.SetUniform3f(p,"marifx_grading","gradepow",gvars.gradepow);
		Shader.SetUniform3f(p,"marifx_grading","gradecol",gvars.gradecol);
		Shader.SetUniform1f(p,"marifx_grading","gradecolfact",gvars.gradecolfact);
		Shader.SetUniform1f(p,"marifx_grading","gradesatmul",gvars.gradesatmul);
		Shader.SetUniform1f(p,"marifx_grading","gradesatpow",gvars.gradesatpow);
		Shader.SetUniform1f(p,"marifx_grading","gradevalmul",gvars.gradevalmul);
		Shader.SetUniform1f(p,"marifx_grading","gradevalpow",gvars.gradevalpow);
	}
}

// note: under no circumstance should the "mkFog" RNG be used for
// anything but clientside actions

Class mkSnow : Actor
{
	Default
	{
		Radius 2;
		Height 2;
		RenderStyle "Translucent";
		+NOGRAVITY;
		+NOBLOCKMAP;
		+MISSILE;
		+DONTSPLASH;
		+THRUACTORS;
		+FORCEXYBILLBOARD;
		FloatBobPhase 0;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if ( ceilingpic != skyflatnum )
		{
			Destroy();
			return;
		}
		Scale *= FRandom[mkFog](0.8,1.6);
		Alpha = FRandom[mkFog](0.1,0.4);
		Vel.X = FRandom[mkFog](-0.1,0.1);
		Vel.Y = FRandom[mkFog](-0.1,0.1);
		Vel.Z = FRandom[mkFog](-0.4,-1.2);
	}
	States
	{
	Spawn:
		SPCK A -1;
		Stop;
	Death:
		SPCK A 1 A_FadeOut(0.03);
		Wait;
	}
}

Class mkSnowMaker : Actor
{
	bool active;

	override void Activate( Actor activator )
	{
		if ( activator.player && (activator.player != players[consoleplayer]) )
			return;
		active = true;
	}
	override void Deactivate( Actor activator )
	{
		if ( activator.player && (activator.player != players[consoleplayer]) )
			return;
		active = false;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		active = !bSTANDSTILL;
	}

	action void A_DoSnow()
	{
		if ( !invoker.active ) return;
		// pick random spots within volume
		double x = args[0];
		double y = args[1];
		double z = args[2];
		int num = args[3];
		for ( int i=0; i<num; i++ )
		{
			Vector3 spawnpos = pos+(FRandom[mkFog](-x,x),FRandom[mkFog](-y,y),FRandom[mkFog](-z,z));
			if ( !level.IsPointInMap(spawnpos) )
				continue;
			let f = Spawn("mkSnow",spawnpos);
			f.master = invoker;
		}
	}
	Default
	{
		//$Title Snow Generator
		//$Category Marisa/FX
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	States
	{
	Spawn:
		TNT1 A 3 A_DoSnow();
		Wait;
	}
}

Class mkFog : Actor
{
	int lifespan, lifetime;
	double basealpha;

	Default
	{
		Radius 16;
		Height 32;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
		+FORCEXYBILLBOARD;
		+THRUACTORS;
		Scale 3.0;
		RenderStyle "Shaded";
		StencilColor "FFFFFF";
		FloatBobPhase 0;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		double ang, pt;
		scale *= FRandom[mkFog](0.75,1.25);
		basealpha = FRandom[mkFog](0.05,0.2);
		ang = FRandom[mkFog](0,360);
		pt = FRandom[mkFog](-90,90);
		vel = (cos(pt)*cos(ang),cos(pt)*sin(ang),-sin(pt))*FRandom[mkFog](0.1,0.4);
		lifespan = Random[mkFog](100,300);
		lifetime = 0;
		SetState(FindState("Spawn")+Random[mkFog](0,19));
	}
	override void Tick()
	{
		Super.Tick();
		double lifephase = lifetime/double(lifespan);
		alpha = sin(lifephase*180.0)*basealpha;
		lifetime++;
		if ( lifetime >= lifespan ) Destroy();
	}
	States
	{
	Spawn:
		DUST ABCDEFGHIJKLMNOPQRST -1;
		Stop;
	}
}

Class mkFogMaker : Actor
{
	bool active;

	override void Activate( Actor activator )
	{
		if ( activator.player && (activator.player != players[consoleplayer]) )
			return;
		active = true;
	}
	override void Deactivate( Actor activator )
	{
		if ( activator.player && (activator.player != players[consoleplayer]) )
			return;
		active = false;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		active = !bSTANDSTILL;
	}

	action void A_DoFog()
	{
		if ( !invoker.active ) return;
		// pick random spots within volume
		double x = args[0];
		double y = args[1];
		double z = args[2];
		int num = args[3];
		for ( int i=0; i<num; i++ )
		{
			Vector3 spawnpos = pos+(FRandom[mkFog](-x,x),FRandom[mkFog](-y,y),FRandom[mkFog](-z,z));
			if ( !level.IsPointInMap(spawnpos) )
				continue;
			let f = Spawn("mkFog",spawnpos);
			f.scale *= 1.+0.1*args[4];
			f.master = invoker;
		}
	}
	Default
	{
		//$Title Fog Generator
		//$Category Marisa/FX
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	States
	{
	Spawn:
		TNT1 A 3 A_DoFog();
		Wait;
	}
}

Class mkBreakGlass : Actor
{
	Default
	{
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		for ( int i=0; i<64; i++ )
		{
			Vector3 shardpos = Vec3Angle(FRandom[Glass](-25,25),angle+90,FRandom[Glass](-50,50));
			String scls = String.Format("SGShard%d",Random[Glass](0,9));
			let s = Spawn(scls,shardpos);
			s.A_SetTranslation('mkGlass');
			s.bNOGRAVITY = false;
			s.Gravity = 0.04;
			double ang = angle+FRandom[Glass](-15,15);
			s.vel.xy = (cos(ang),sin(ang))*FRandom[Glass](0.8,3.2);
			s.vel.z = FRandom[Glass](0.2,0.8);
		}
		Destroy();
	}
}

Class mkWarpPipe : Actor
{
	int cnt;
	static void WarpScream( Actor caller )
	{
		caller.A_PlaySound("*falling",CHAN_VOICE,1.0,false,ATTN_NONE,true);
	}
	Default
	{
		//$Title Warp Tunnel
		//$Category Marisa/FX
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
		+ROLLSPRITE;
		+INTERPOLATEANGLES;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		A_PlaySound("EtherealTeleport",CHAN_BODY,1.0,true,16.0);
	}
	override void Tick()
	{
		Super.Tick();
		cnt++;
		angle = sin(cnt*1.333)*12;
		pitch = cos(cnt*1.666)*6;
		roll = sin(cnt*0.888)*3;
	}
	States
	{
	Spawn:
		PRKM A -1 Bright;
		Stop;	}
}

Class mkIceIceBaby : Actor
{
	Default
	{
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		for ( int i=0; i<256; i++ )
		{
			Vector3 shardpos = Vec3Offset(FRandom[Glass](-60,60),FRandom[Glass](-60,60),FRandom[Glass](-156,156));
			let s = Spawn("IceChunk",shardpos);
			double ang = angle+FRandom[Glass](0,360);
			s.scale *= FRandom[Glass](1.2,2.2);
			s.vel.xy = (cos(ang),sin(ang))*FRandom[Glass](1.2,4.5);
			s.vel.z = FRandom[Glass](0.6,3.6);
		}
		Destroy();
	}
}
