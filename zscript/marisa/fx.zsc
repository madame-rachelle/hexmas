Struct marifx_gradingvars
{
	Vector3 grademul, gradepow, gradecol;
	float gradecolfact, gradesatmul, gradesatpow, gradevalmul, gradevalpow;
};

Class mkGradingHandler : EventHandler
{
	// color grading (with transitions)
	double gspeed, gphase;
	bool genabled;
	marifx_gradingvars gvars, gvars_in, gvars_out;

	static void GradingTransition( Actor activator, int preset, double speed = 1.0, bool local = false )
	{
		let hnd = mkGradingHandler(EventHandler.Find("mkGradingHandler"));
		if ( !hnd ) return;
		if ( local && activator && (activator.player != players[consoleplayer]) ) return;
		switch ( preset )
		{
		case 0:
			// outdoor preset
			hnd.gvars_out.grademul = (0.99,1.03,1.09);
			hnd.gvars_out.gradepow = (1.01,1.03,0.87);
			hnd.gvars_out.gradecol = (-0.46,-0.31,-0.82);
			hnd.gvars_out.gradecolfact = -0.18;
			hnd.gvars_out.gradesatmul = 0.88;
			hnd.gvars_out.gradesatpow = 1.31;
			hnd.gvars_out.gradevalmul = 0.91;
			hnd.gvars_out.gradevalpow = 1.38;
			break;
		case 1:
			// indoor preset
			hnd.gvars_out.grademul = (1.02,1.11,0.96);
			hnd.gvars_out.gradepow = (1.09,1.03,0.94);
			hnd.gvars_out.gradecol = (-0.11,-0.69,-0.33);
			hnd.gvars_out.gradecolfact = -0.24;
			hnd.gvars_out.gradesatmul = 0.78;
			hnd.gvars_out.gradesatpow = 1.22;
			hnd.gvars_out.gradevalmul = 1.07;
			hnd.gvars_out.gradevalpow = 1.25;
			break;
		case 2:
			// deep preset
			hnd.gvars_out.grademul = (0.91,1.06,0.93);
			hnd.gvars_out.gradepow = (1.02,0.88,1.09);
			hnd.gvars_out.gradecol = (-0.24,-0.43,-0.19);
			hnd.gvars_out.gradecolfact = -0.22;
			hnd.gvars_out.gradesatmul = 0.93;
			hnd.gvars_out.gradesatpow = 1.13;
			hnd.gvars_out.gradevalmul = 1.08;
			hnd.gvars_out.gradevalpow = 1.51;
			break;
		case 3:
			// stronghold preset
			hnd.gvars_out.grademul = (1.08,1.06,0.92);
			hnd.gvars_out.gradepow = (0.93,1.05,0.99);
			hnd.gvars_out.gradecol = (-0.5,-0.26,-0.15);
			hnd.gvars_out.gradecolfact = -0.19;
			hnd.gvars_out.gradesatmul = 0.97;
			hnd.gvars_out.gradesatpow = 1.23;
			hnd.gvars_out.gradevalmul = 0.96;
			hnd.gvars_out.gradevalpow = 1.47;
			break;
		case 4:
			// minotaur preset
			hnd.gvars_out.grademul = (1.12,0.95,0.87);
			hnd.gvars_out.gradepow = (0.91,1.04,1.13);
			hnd.gvars_out.gradecol = (-0.79,-0.22,0.22);
			hnd.gvars_out.gradecolfact = -0.29;
			hnd.gvars_out.gradesatmul = 0.86;
			hnd.gvars_out.gradesatpow = 1.11;
			hnd.gvars_out.gradevalmul = 0.82;
			hnd.gvars_out.gradevalpow = 1.78;
			break;
		}
		hnd.genabled = true;
		hnd.gphase = 0;
		hnd.gspeed = speed/Thinker.TICRATE;
		if ( speed <= 0 )
		{
			hnd.gspeed = 0;
			hnd.gvars.grademul = hnd.gvars_out.grademul;
			hnd.gvars.gradepow = hnd.gvars_out.gradepow;
			hnd.gvars.gradecol = hnd.gvars_out.gradecol;
			hnd.gvars.gradecolfact = hnd.gvars_out.gradecolfact;
			hnd.gvars.gradesatmul = hnd.gvars_out.gradesatmul;
			hnd.gvars.gradesatpow = hnd.gvars_out.gradesatpow;
			hnd.gvars.gradevalmul = hnd.gvars_out.gradevalmul;
			hnd.gvars.gradevalpow = hnd.gvars_out.gradevalpow;
		}
		hnd.gvars_in.grademul = hnd.gvars.grademul;
		hnd.gvars_in.gradepow = hnd.gvars.gradepow;
		hnd.gvars_in.gradecol = hnd.gvars.gradecol;
		hnd.gvars_in.gradecolfact = hnd.gvars.gradecolfact;
		hnd.gvars_in.gradesatmul = hnd.gvars.gradesatmul;
		hnd.gvars_in.gradesatpow = hnd.gvars.gradesatpow;
		hnd.gvars_in.gradevalmul = hnd.gvars.gradevalmul;
		hnd.gvars_in.gradevalpow = hnd.gvars.gradevalpow;
	}

	override void WorldTick()
	{
		if ( gspeed <= 0 ) return;
		gphase += gspeed;
		gphase = min(gphase,1);
		gvars.grademul = gvars_in.grademul*(1-gphase)+gvars_out.grademul*gphase;
		gvars.gradepow = gvars_in.gradepow*(1-gphase)+gvars_out.gradepow*gphase;
		gvars.gradecol = gvars_in.gradecol*(1-gphase)+gvars_out.gradecol*gphase;
		gvars.gradecolfact = gvars_in.gradecolfact*(1-gphase)+gvars_out.gradecolfact*gphase;
		gvars.gradesatmul = gvars_in.gradesatmul*(1-gphase)+gvars_out.gradesatmul*gphase;
		gvars.gradesatpow = gvars_in.gradesatpow*(1-gphase)+gvars_out.gradesatpow*gphase;
		gvars.gradevalmul = gvars_in.gradevalmul*(1-gphase)+gvars_out.gradevalmul*gphase;
		gvars.gradevalpow = gvars_in.gradevalpow*(1-gphase)+gvars_out.gradevalpow*gphase;
		if ( gphase >= 1 )
		{
			gphase = 0;
			gspeed = 0;
		}
	}

	override void WorldLoaded( WorldEvent e )
	{
		gvars.grademul = (1.0,1.0,1.0);
		gvars.gradepow = (1.0,1.0,1.0);
		gvars.gradecol = (1.0,1.0,1.0);
		gvars.gradecolfact = 0.0;
		gvars.gradesatmul = 1.0;
		gvars.gradesatpow = 1.0;
		gvars.gradevalmul = 1.0;
		gvars.gradevalpow = 1.0;
		if ( level.mapname ~== "MARISA" )
			GradingTransition(null,0,0);
	}

	override void RenderOverlay( RenderEvent e )
	{
		PlayerInfo p = players[consoleplayer];
		Shader.SetEnabled(p,"marifx_grading",genabled);
		if ( !genabled ) return;
		Shader.SetUniform3f(p,"marifx_grading","grademul",gvars.grademul);
		Shader.SetUniform3f(p,"marifx_grading","gradepow",gvars.gradepow);
		Shader.SetUniform3f(p,"marifx_grading","gradecol",gvars.gradecol);
		Shader.SetUniform1f(p,"marifx_grading","gradecolfact",gvars.gradecolfact);
		Shader.SetUniform1f(p,"marifx_grading","gradesatmul",gvars.gradesatmul);
		Shader.SetUniform1f(p,"marifx_grading","gradesatpow",gvars.gradesatpow);
		Shader.SetUniform1f(p,"marifx_grading","gradevalmul",gvars.gradevalmul);
		Shader.SetUniform1f(p,"marifx_grading","gradevalpow",gvars.gradevalpow);
	}
}

// note: under no circumstance should the "mkFog" RNG be used for
// anything but clientside actions


Class mkSnow : Actor
{
	Default
	{
		Radius 2;
		Height 2;
		RenderStyle "Translucent";
		+NOGRAVITY;
		+NOBLOCKMAP;
		+MISSILE;
		+DONTSPLASH;
		+THRUACTORS;
		+FORCEXYBILLBOARD;
		FloatBobPhase 0;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if ( ceilingpic != skyflatnum )
		{
			Destroy();
			return;
		}
		Scale *= FRandom[mkFog](0.8,1.6);
		Alpha = FRandom[mkFog](0.1,0.4);
		Vel.X = FRandom[mkFog](-0.1,0.1);
		Vel.Y = FRandom[mkFog](-0.1,0.1);
		Vel.Z = FRandom[mkFog](-0.4,-1.2);
	}
	States
	{
	Spawn:
		SPCK A -1;
		Stop;
	Death:
		SPCK A 1 A_FadeOut(0.03);
		Wait;
	}
}

Class mkSnowMaker : Actor
{
	bool active;

	override void Activate( Actor activator )
	{
		if ( activator.player && (activator.player != players[consoleplayer]) )
			return;
		active = true;
	}
	override void Deactivate( Actor activator )
	{
		if ( activator.player && (activator.player != players[consoleplayer]) )
			return;
		active = false;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		active = !bSTANDSTILL;
	}

	action void A_DoSnow()
	{
		if ( !invoker.active ) return;
		// pick random spots within volume
		double x = args[0];
		double y = args[1];
		double z = args[2];
		int num = args[3];
		for ( int i=0; i<num; i++ )
		{
			Vector3 spawnpos = pos+(FRandom[mkFog](-x,x),FRandom[mkFog](-y,y),FRandom[mkFog](-z,z));
			if ( !level.IsPointInMap(spawnpos) )
				continue;
			if ( level.Vec2Diff(players[consoleplayer].camera.pos.xy,spawnpos.xy).length() > 800 )
				continue;
			let f = Spawn("mkSnow",spawnpos);
			f.master = invoker;
		}
		special1++;
		if ( special1 >= 6 )
		{
			special1 = 0;
			score = 0;
			let t = ThinkerIterator.Create("mkSnow");
			while ( t.Next() ) score++;
		}
		if ( score > 200 ) A_SetTics(12);
		else if ( score > 160 ) A_SetTics(10);
		else if ( score > 120 ) A_SetTics(8);
		else if ( score > 80 ) A_SetTics(6);
	}
	Default
	{
		//$Title Snow Generator
		//$Category Marisa/FX
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	States
	{
	Spawn:
		TNT1 A 4 A_DoSnow();
		Wait;
	}
}

Class mkFog : Actor
{
	int lifespan, lifetime;
	double basealpha;

	Default
	{
		Radius 16;
		Height 32;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
		+FORCEXYBILLBOARD;
		+THRUACTORS;
		Scale 3.0;
		RenderStyle "Shaded";
		StencilColor "FFFFFF";
		FloatBobPhase 0;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		double ang, pt;
		scale *= FRandom[mkFog](0.75,1.25);
		basealpha = FRandom[mkFog](0.05,0.2);
		ang = FRandom[mkFog](0,360);
		pt = FRandom[mkFog](-90,90);
		vel = (cos(pt)*cos(ang),cos(pt)*sin(ang),-sin(pt))*FRandom[mkFog](0.1,0.4);
		lifespan = Random[mkFog](100,200);
		lifetime = 0;
		SetState(FindState("Spawn")+Random[mkFog](0,19));
	}
	override void Tick()
	{
		Super.Tick();
		double lifephase = lifetime/double(lifespan);
		alpha = sin(lifephase*180.0)*basealpha;
		lifetime++;
		if ( lifetime >= lifespan ) Destroy();
	}
	States
	{
	Spawn:
		DUST ABCDEFGHIJKLMNOPQRST -1;
		Stop;
	}
}

Class mkFogMaker : Actor
{
	bool active;

	override void Activate( Actor activator )
	{
		if ( activator.player && (activator.player != players[consoleplayer]) )
			return;
		active = true;
	}
	override void Deactivate( Actor activator )
	{
		if ( activator.player && (activator.player != players[consoleplayer]) )
			return;
		active = false;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		active = !bSTANDSTILL;
	}

	action void A_DoFog()
	{
		if ( !invoker.active ) return;
		// pick random spots within volume
		double x = args[0];
		double y = args[1];
		double z = args[2];
		int num = args[3];
		for ( int i=0; i<num; i++ )
		{
			Vector3 spawnpos = pos+(FRandom[mkFog](-x,x),FRandom[mkFog](-y,y),FRandom[mkFog](-z,z));
			if ( !level.IsPointInMap(spawnpos) )
				continue;
			if ( level.Vec3Diff(players[consoleplayer].camera.pos,spawnpos).length() > 1200 )
				continue;
			let f = Spawn("mkFog",spawnpos);
			f.scale *= 1.+0.1*args[4];
			f.master = invoker;
		}
		special1++;
		if ( special1 >= 6 )
		{
			special1 = 0;
			score = 0;
			let t = ThinkerIterator.Create("mkFog");
			while ( t.Next() ) score++;
		}
		if ( score > 200 ) A_SetTics(12);
		else if ( score > 160 ) A_SetTics(10);
		else if ( score > 120 ) A_SetTics(8);
		else if ( score > 80 ) A_SetTics(6);
	}
	Default
	{
		//$Title Fog Generator
		//$Category Marisa/FX
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	States
	{
	Spawn:
		TNT1 A 4 A_DoFog();
		Wait;
	}
}

Class mkBreakGlass : Actor
{
	Default
	{
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		for ( int i=0; i<64; i++ )
		{
			Vector3 shardpos = Vec3Angle(FRandom[Glass](-25,25),angle+90,FRandom[Glass](-50,50));
			String scls = String.Format("SGShard%d",Random[Glass](0,9));
			let s = Spawn(scls,shardpos);
			s.A_SetTranslation('mkGlass');
			s.bNOGRAVITY = false;
			s.Gravity = 0.04;
			double ang = angle+FRandom[Glass](-15,15);
			s.vel.xy = (cos(ang),sin(ang))*FRandom[Glass](0.8,3.2);
			s.vel.z = FRandom[Glass](0.2,0.8);
		}
		Destroy();
	}
}

Class mkBreakGlassNormal : Actor
{
	Default
	{
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		for ( int i=0; i<64; i++ )
		{
			Vector3 shardpos = Vec3Angle(FRandom[Glass](-25,25),angle+90,FRandom[Glass](-50,50));
			String scls = String.Format("SGShard%d",Random[Glass](0,9));
			let s = Spawn(scls,shardpos);
			s.bNOGRAVITY = false;
			s.Gravity = 0.04;
			double ang = angle+FRandom[Glass](-15,15);
			s.vel.xy = (cos(ang),sin(ang))*FRandom[Glass](0.8,3.2);
			s.vel.z = FRandom[Glass](0.2,0.8);
		}
		Destroy();
	}
}

Class mkWarpPipe : Actor
{
	int cnt;
	static void WarpScream( Actor caller )
	{
		caller.A_PlaySound("*falling",CHAN_VOICE,1.0,false,ATTN_NONE,true);
	}
	Default
	{
		//$Title Warp Tunnel
		//$Category Marisa/FX
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
		+ROLLSPRITE;
		+INTERPOLATEANGLES;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		A_PlaySound("EtherealTeleport",CHAN_BODY,1.0,true,16.0);
	}
	override void Tick()
	{
		Super.Tick();
		cnt++;
		angle = sin(cnt*1.333)*12;
		pitch = cos(cnt*1.666)*6;
		roll = sin(cnt*0.888)*3;
	}
	States
	{
	Spawn:
		PRKM A -1 Bright;
		Stop;	}
}

Class mkIceIceBaby : Actor
{
	Default
	{
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		for ( int i=0; i<256; i++ )
		{
			Vector3 shardpos = Vec3Offset(FRandom[Glass](-28,28),FRandom[Glass](-28,28),FRandom[Glass](-72,72));
			let s = Spawn("IceChunk",shardpos);
			double ang = angle+FRandom[Glass](0,360);
			s.scale *= FRandom[Glass](0.4,1.4);
			s.vel.xy = (cos(ang),sin(ang))*FRandom[Glass](1.2,4.5);
			s.vel.z = FRandom[Glass](0.6,3.6);
		}
		Destroy();
	}
}

Class mkUtility abstract
{
	static play void SpawnProjectile( String cls, int spot, int speed = -1 )
	{
		Actor src;
		let ai = ActorIterator.Create(spot);
		while ( src = ai.Next() )
		{
			let p = Actor.Spawn(cls,src.pos);
			p.angle = src.angle;
			p.pitch = src.pitch;
			p.vel = (cos(p.angle)*cos(p.pitch),sin(p.angle)*cos(p.pitch),-sin(p.pitch))*((speed!=-1)?speed:p.speed);
		}
	}

	static play void SpawnProjectileAimed( String cls, int spot, int target, int spread = 0, int speed = -1 )
	{
		Actor src;
		let ai = ActorIterator.Create(spot);
		while ( src = ai.Next() )
		{
			Actor dst = ActorIterator.Create(target).Next();
			let p = Actor.Spawn(cls,src.pos);
			Vector3 dir = level.Vec3Diff(src.pos,dst.pos);
			dir = dir.unit();
			p.angle = atan2(dir.y,dir.x)+FRandom[mkutilrng](-spread,spread);
			p.pitch = asin(-dir.z)+FRandom[mkutilrng](-spread,spread);
			p.vel = (cos(p.angle)*cos(p.pitch),sin(p.angle)*cos(p.pitch),-sin(p.pitch))*((speed!=-1)?speed:p.speed);
		}
	}

	static play void SetSectorFloorLight( int tag, int val )
	{
		let s = SectorTagIterator.Create(tag);
		int i;
		while ( (i = s.Next()) != -1 ) level.Sectors[i].SetPlaneLight(0,val);
	}

	static play void SetActorZ( int tag, int newz )
	{
		Actor a;
		let ai = ActorIterator.Create(tag);
		while ( a = ai.Next() )
		{
			a.SetZ(newz);
		}
	}

	static play void SetLineFullbright( int tag )
	{
		let l = LineIdIterator.Create(tag);
		int i;
		while ( (i = l.Next()) != -1 )
		{
			level.Lines[i].sidedef[0].light = 255;
			level.Lines[i].sidedef[0].flags |= Side.WALLF_ABSLIGHTING;
			if ( !level.Lines[i].sidedef[1] ) continue;
			level.Lines[i].sidedef[1].light = 255;
			level.Lines[i].sidedef[1].flags |= Side.WALLF_ABSLIGHTING;
		}
	}
}

Class mkMovingFloorTrap : Actor abstract
{
	enum EDir
	{
		DIR_EAST,
		DIR_NORTH,
		DIR_WEST,
		DIR_SOUTH,
	}

	int mdir;
	int dcnt, hcnt;

	property Dir: mdir;

	override void Tick()
	{
		Vel *= 0;
		Super.Tick();
	}

	bool MoveDown()
	{
		SetOrigin(Vec3Offset(0,0,-2),true);
		return (++dcnt>=4);
	}
	bool MoveDir()
	{
		SetOrigin(Vec3Offset(cos(mdir*90)*6,sin(mdir*90)*6,0),true);
		return (++hcnt>=20);
	}

	override void Activate( Actor activator )
	{
		if ( !InStateSequence(CurState,FindState("Spawn")) ) return;
		SetStateLabel("Activated");
	}

	void StartSq()
	{
		StartSoundSequence('Platform',0);
	}

	void StopSq()
	{
		StopSoundSequence();
	}

	Default
	{
		+SOLID;
		+SHOOTABLE;
		+NODAMAGE;
		+NOBLOOD;
		+ACTLIKEBRIDGE;
		+NOGRAVITY;
		+DONTTHRUST;
		Mass int.max;
		Radius 64;
		Height 16;
	}
	States
	{
	Spawn:
		PRKM A -1;
		Stop;
	Activated:
		PRKM A 0 StartSq();
		PRKM A 1 A_JumpIf(MoveDown(),1);
		Wait;
		PRKM A 30 StopSq();
		PRKM A 0 StartSq();
		PRKM A 1 A_JumpIf(MoveDir(),1);
		Wait;
		PRKM A -1 StopSq();
		Stop;
	}
}

Class mkMovingFloorTrapE : mkMovingFloorTrap
{
	Default
	{
		//$Title Moving Floor Trap (East)
		//$Category Marisa/FX
		mkMovingFloorTrap.Dir DIR_EAST;
	}
}
Class mkMovingFloorTrapN : mkMovingFloorTrap
{
	Default
	{
		//$Title Moving Floor Trap (North)
		//$Category Marisa/FX
		mkMovingFloorTrap.Dir DIR_NORTH;
	}
}
Class mkMovingFloorTrapW : mkMovingFloorTrap
{
	Default
	{
		//$Title Moving Floor Trap (West)
		//$Category Marisa/FX
		mkMovingFloorTrap.Dir DIR_WEST;
	}
}
Class mkMovingFloorTrapS : mkMovingFloorTrap
{
	Default
	{
		//$Title Moving Floor Trap (South)
		//$Category Marisa/FX
		mkMovingFloorTrap.Dir DIR_SOUTH;
	}
}

Class mkFindUseTracer : LineTracer
{
	Actor skipme;

	override ETraceStatus TraceCallback()
	{
		if ( Results.HitType == TRACE_HitActor )
		{
			if ( (Results.HitActor != skipme) && Results.HitActor.bUSESPECIAL ) return TRACE_Stop;
			return TRACE_Skip;
		}
		else if ( Results.HitType == TRACE_HitWall )
		{
			if ( Results.HitLine.Activation&SPAC_USE ) return TRACE_Stop;
			else if ( Results.HitLine.flags&(Line.ML_BLOCKING|Line.ML_BLOCKEVERYTHING|Line.ML_BLOCKUSE) ) return TRACE_Abort;
			return TRACE_Skip;
		}
		return TRACE_Abort;
	}
}

Class mkUsableMessage : HUDMessageBase
{
	bool active;
	String ustr;

	override void Draw( int bottom, int visibility )
	{
		if ( !active ) return;
		Vector2 hscale = StatusBar.GetHudScale();
		Vector2 vsize = (Screen.GetWidth()/hscale.x,Screen.GetHeight()/hscale.y);
		double xpos = (vsize.x-smallfont.StringWidth(ustr))*0.5;
		double ypos = (bottom/hscale.y)-smallfont.GetHeight()*3;
		Screen.DrawText(smallfont,Font.CR_WHITE,xpos,ypos,ustr,DTA_VirtualWidthF,vsize.x,DTA_VirtualHeightF,vsize.y,DTA_KeepRatio,true);
	}
}

// class for highlighting the usability of certain non-obvious lines in my map
Class mkHighlightUsables : EventHandler
{
	bool LookUsable[MAXPLAYERS];
	String UsableName[MAXPLAYERS];
	transient mkFindUseTracer t;
	ui mkUsableMessage msg;

	override void WorldTick()
	{
		if ( !t ) t = new("mkFindUseTracer");
		for ( int i=0; i<MAXPLAYERS; i++ )
		{
			if ( !playeringame[i] ) continue;
			PlayerInfo p = players[i];
			t.skipme = p.mo;
			Vector3 tracedir = (cos(p.mo.angle),sin(p.mo.angle),0);
			t.Trace(p.mo.Vec2OffsetZ(0,0,p.viewz),p.mo.CurSector,tracedir,p.mo.userange,0);
			LookUsable[i] = (t.Results.HitType == TRACE_HitWall);
			if ( t.Results.HitType != TRACE_HitWall )
			{
				LookUsable[i] = false;
				continue;
			}
			// guess what this is
			Line l = t.Results.HitLine;
			if ( (l.special != 80) && (l.special != 226) )
			{
				LookUsable[i] = false;
				continue;
			}
			if ( l.args[0] == -Int('SomethingInside') ) UsableName[i] = "Check Casket";
			else if ( l.args[0] == -Int('TimTheToolmanTaylor') ) UsableName[i] = "???";
			else if ( l.args[0] == -Int('Mirror') ) UsableName[i] = "Check Mirror";
			else if ( l.args[0] == -Int('Closet') ) UsableName[i] = "Check Closet";
			else if ( l.args[0] == -Int('Bookworm') )
			{
				switch( l.args[2] )
				{
				case 1:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
				case 11:
					UsableName[i] = "Check Bookshelf";
					break;
				case 2:
				case 12:
				case 13:
					UsableName[i] = "Check Book";
					break;
				case 14:
				case 15:
				case 17:
					UsableName[i] = "Read Diary";
					break;
				case 16:
				case 18:
				case 20:
					UsableName[i] = "Read Engraving";
					break;
				case 19:
					UsableName[i] = "Read Note";
					break;
				}
			}
			else LookUsable[i] = false;
		}
	}

	override void PostUiTick()
	{
		if ( !msg )
		{
			msg = new("mkUsableMessage");
			StatusBar.AttachMessage(msg);
		}
		if ( !LookUsable[consoleplayer] || (players[consoleplayer].mo != players[consoleplayer].camera) )
		{
			msg.active = false;
			return;
		}
		msg.active = true;
		msg.ustr = UsableName[consoleplayer];
	}
}
