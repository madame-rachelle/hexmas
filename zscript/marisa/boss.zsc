// The Viridescent Lord.
// The weakest of the Lords of Terror.
// The Nightmare Lord being right above him in strength.
// The strongest will appear someday... in another project.
Class mkElderWizard : Actor
{
	const TELESPOT_TID = 13001;
	const LITE_TID = 77;
	const SKYBOX_TAG = 44;

	Array<Actor> TeleSpots;
	int last_tele;
	int meleecharge, mcnt;
	int lchg;
	int fires;
	bool phasetwo;
	int p2health, mhealth;
	int musing, mtimer;

	static void KillCult()
	{
		let t = ThinkerIterator.Create("Actor");
		Actor a;
		while ( a = Actor(t.Next()) )
		{
			if ( (a.Health <= 0) || (!(a is 'mkElderApprentice') && !(a is 'mkElderAcolyte') && !(a.master && (a.master is 'mkElderWizard'))) ) continue;
			if ( a.bDORMANT ) a.Activate(null);
			a.DamageMobj(null,null,int.max,'Silent',DMG_FORCED|DMG_THRUSTLESS);
		}
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		mtimer = 10;
		// inflate health
		int nplayers = 0;
		for ( int i=0; i<MAXPLAYERS; i++ ) if ( playeringame[i] ) nplayers++;
		Health += (G_SkillPropertyInt(SKILLP_ACSReturn)-2)*2000;
		Health += 250*(nplayers-1)*G_SkillPropertyInt(SKILLP_ACSReturn);
		mhealth = health;
		p2health = int(Health*0.15);
		// populate arrays
		ActorIterator t = ActorIterator.Create(TELESPOT_TID);
		Actor a;
		while ( a = t.Next() ) TeleSpots.Push(a);
		// set last spot to the closest in the array
		int closest = -1;
		double mindist = double.infinity;
		for ( int i=0; i<TeleSpots.Size(); i++ )
		{
			double dist = Distance3D(TeleSpots[i]);
			if ( dist > mindist ) continue;
			mindist = dist;
			closest = i;
		}
		last_tele = closest;
	}

	override int DamageMobj( Actor inflictor, Actor source, int damage, Name mod, int flags, double angle )
	{
		// gratly reduce damage while doing phase two intro
		if ( InStateSequence(CurState,FindState("PhaseTwoStart")) || InStateSequence(CurState,FindState("PhaseTwoBoom")) ) damage = int(damage*0.1);
		// amplify otherwise before phase two
		if ( !phasetwo ) damage = int(damage*2.5);
		// reduce damage while attacking
		if ( !InStateSequence(CurState,FindState("See")) ) damage = int(damage*0.75);
		// reduce attack cooldown when damaged by players or friendlies
		if ( phasetwo && (damage > 0) && source && (source.player || source.bFRIENDLY) ) mcnt -= Random[EWizDecide](3,9);
		// phase two safeguard to not break scripts when cheating
		if ( (Health-damage <= 0) && !phasetwo )
			ACS_NamedExecute('LordPhaseTwo');
		return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
	}

	// charge melee attack if players nearby
	void A_WizCheckMelee()
	{
		if ( p2health && (Health < p2health) )
		{
			p2health = 0;
			SetStateLabel("PhaseTwoStart");
			return;
		}
		if ( !phasetwo )
		{
			mtimer--;
			if ( mtimer <= 0 )
			{
				switch ( musing )
				{
				case 0:
					A_PrintBold("\cdI know you have come for the gem, mortal.");
					break;
				case 1:
					A_PrintBold("\cdIf you think I am going to hand it over, think again.");
					break;
				case 2:
					A_PrintBold("\cdIts potential is much greater than you could ever imagine.");
					break;
				case 3:
					A_PrintBold("\cdThe old sage doesn't even know... what it is capable of.");
					break;
				case 4:
					A_PrintBold("\cdOnly I have the knowledge... Only I can truly harness its full power.");
					break;
				case 5:
					A_PrintBold("\cdWith the serpent riders now gone it is my chance.");
					break;
				case 6:
					A_PrintBold("\cdBut you... Do you think you can stop me?");
					break;
				case 7:
					A_PrintBold("\cdYou severely underestimate me, mortal.");
					break;
				case 8:
					A_PrintBold("\cdThe knowledge, the power... Everything HE has given me...");
					break;
				case 9:
					A_PrintBold("\cdI will not let it all go to waste!");
					break;
				}
				if ( musing <= 9 ) A_PlaySound(ActiveSound,CHAN_5,attenuation:ATTN_NONE);
				musing++;
				mtimer = 70;
			}
		}
		if ( !target || (target.Health <= 0) )
		{
			A_ClearTarget();
			SetStateLabel("Spawn");
			return;
		}
		A_FaceTarget(15);
		if ( Random[EWizardAct]() < 6 )
		{
			if ( phasetwo ) A_QuakeEx(2,2,2,50,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
			PlayActiveSound();
		}
		if ( phasetwo )
		{
			bool inrange = false;
			for ( int i=0; i<MAXPLAYERS; i++ )
			{
				if ( !playeringame[i] ) continue;
				double dist = Distance2D(players[i].mo);
				if ( dist > 120 ) continue;
				inrange = true;
				if ( (meleecharge > 40) && !Random[EWizMelee](0,10) && (dist < 90) )
					players[i].mo.DamageMobj(self,self,meleecharge/40,'Melee',0,AngleTo(players[i].mo));
			}
			if ( inrange ) meleecharge += Random[EWizMelee](1,3);
			else meleecharge = max(0,meleecharge-4);
			for ( int i=0; i<10; i++ )
			{
				double ang = 36*i+FRandom[EWizPoof](-18.,18.);
				let p = Spawn("mkRisingMeleePoof",Vec3Angle(FRandom[EWizPoof](radius,100),ang,8));
				p.vel.xy = (cos(ang),sin(ang))*FRandom[EWizPoof](1.0,3.0);
				p.alpha = meleecharge/500.;
			}
			if ( meleecharge > 100 )
			{
				meleecharge = 0;
				SetStateLabel("Melee");
			}
		}
		else if ( CheckMeleeRange() )
		{
			SetStateLabel("MeleeSmall");
			return;
		}
		mcnt--;
		if ( (mcnt <= 0) && (meleecharge <= 0) ) SetState(CurState+1);
	}

	void A_WizMeleePuffs( bool orient = false )
	{
		if ( orient ) A_FaceTarget(15);
		for ( int i=0; i<MAXPLAYERS; i++ )
		{
			if ( !playeringame[i] || (Distance2D(players[i].mo) > 80) ) continue;
			if ( !Random[EWizMelee](0,8) )
				players[i].mo.DamageMobj(self,self,3,'Melee',0,AngleTo(players[i].mo));
		}
		for ( int i=0; i<10; i++ )
		{
			double ang = 36*i+FRandom[EWizPoof](-18.,18.);
			let p = Spawn("mkRisingMeleePoof",Vec3Angle(FRandom[EWizPoof](radius,100),ang,8));
			p.vel.xy = (cos(ang),sin(ang))*FRandom[EWizPoof](1.0,3.0);
		}
	}

	void A_WizMelee( bool big = false )
	{
		A_QuakeEx(6,6,6,90,0,65535,"",QF_RELATIVE|QF_SCALEDOWN);
		A_PlaySound("SorcererBigBallExplode",CHAN_WEAPON,attenuation:ATTN_NONE);
		A_PlaySound("SorcererBallExplode",CHAN_ITEM,attenuation:ATTN_NONE);
		int mx = big?30:10;
		for ( int i=0; i<mx; i++ )
		{
			double ang = 36*i+FRandom[EWizPoof](-18.,18.);
			let p = Spawn("mkWizMeleeBlast",Vec3Angle(radius,ang,0));
			p.target = self;
			p.vel.xy = (cos(ang),sin(ang))*p.speed;
			if ( big )
			{
				p.scale *= 3.0;
				p.vel *= FRandom[EWizPoof](1.2,1.8);
				p.special1 = 1;
			}
		}
	}

	// choose an attack to use
	void A_WizDecide()
	{
		mcnt = phasetwo?Random[EWizDecide](20,40):Random[EWizDecide](4,12);
		if ( !target || (target.Health <= 0) || !CheckSight(target) ) return;
		if ( Random[EWizDecide](0,1) ) return;
		int dec = Random[EWizDecide](0,12);
		if ( !phasetwo )
		{
			if ( dec <= 6 ) SetStateLabel("SeekingFireball");
			else if ( dec <= 8 )
			{
				// slimy
				int countslimes = 0;
				let t = ThinkerIterator.Create("mkSlime");
				Actor a;
				while ( a = Actor(t.Next()) )
				{
					if ( (a.Health <= 0) || (a.master != self) ) continue;
					countslimes++;
				}
				if ( countslimes < 2 )
					SetStateLabel("CallInSlimes");
			}
			else SetStateLabel("Teleport");
			return;
		}
		if ( dec <= 3 )
		{
			// charged laser
			SetStatelabel("ChargeLaser");
		}
		else if ( dec <= 6 )
		{
			// seeking fireballs
			SetStateLabel("SeekingFireballs");
		}
		else if ( dec <= 8 )
		{
			// 'splode
			SetStateLabel("RadiusBlast");
		}
		else if ( dec <= 10 )
		{
			// teleport
			SetStateLabel("Teleport");
		}
		else
		{
			// spawn enemies
			int countmooks = 0;
			let t = ThinkerIterator.Create("Actor");
			Actor a;
			while ( a = Actor(t.Next()) )
			{
				if ( a is 'mkMookCaller' ) return;
				if ( (a.Health <= 0) || (a.master != self) ) continue;
				countmooks++;
			}
			if ( countmooks <= max(0,G_SkillPropertyInt(SKILLP_ACSReturn)-2) ) SetStateLabel("CallInMooks");
		}
	}

	void A_TeleIn()
	{
		fires++;
		if ( phasetwo ) A_SetTics(Random[EWizTeleport](30,50));
		int rp = 0;
		if ( TeleSpots.Size() > 1 )
		{
			rp = Random[EWizTeleport](0,TeleSpots.Size()-2);
			if ( rp >= last_tele ) rp++;
		}
		last_tele = rp;
		A_TeleportFlash();
		bNODAMAGE = true;
		bSOLID = false;
		bSHOOTABLE = false;
	}

	void A_TeleOut()
	{
		if ( !phasetwo ) A_SetTics(10);
		bNODAMAGE = false;
		bSOLID = true;
		bSHOOTABLE = true;
		if ( TeleSpots.Size() > 0 )
		{
			TeleportMove(TeleSpots[last_tele].pos,true);
			if ( target ) A_FaceTarget();
			else angle = TeleSpots[last_tele].angle;
		}
		else A_FaceTarget();
		A_TeleportFlash();
	}

	void A_DeathFlash()
	{
		A_PlaySound("eldrich/flash",CHAN_WEAPON,attenuation:ATTN_NONE);
		players[consoleplayer].camera.A_SetBlend("80 FF 80",1.,10);
	}

	void A_TeleportFlash()
	{
		if ( phasetwo )
		{
			A_PlaySound("eldrich/tele",CHAN_WEAPON,attenuation:ATTN_NONE);
			A_QuakeEx(4,4,4,50,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
			players[consoleplayer].camera.A_SetBlend("80 FF 80",0.5,25);
			for ( int i=0; i<360; i+=10 )
			{
				let s = Spawn("mkWizDust",pos);
				s.vel.xy = (cos(i),sin(i))*9.0;
			}
			for ( int i=0; i<64; i++ )
				Spawn("mkWizSprinkles",Vec3Offset(FRandom[EWizFX](-radius,radius),FRandom[EWizFX](-radius,radius),FRandom[EWizFX](0,height)));
			for ( int i=0; i<8; i++ )
			{
				let s = Spawn("mkWizAfterImage",pos);
				s.scale = scale;
				s.angle = angle;
				s.vel = vel+(FRandom[EWizFX](-2,2),FRandom[EWizFX](-2,2),FRandom[EWizFX](0,1));
			}
			let b = BlockThingsIterator.Create(self,200);
			while ( b.Next() )
			{
				if ( !b.Thing || !b.Thing.bSHOOTABLE || (b.Thing.Health <= 0) || (b.Thing == self) || (Distance2D(b.Thing) > 150) ) continue;
				b.Thing.DamageMobj(self,self,30,'Melee',DMG_THRUSTLESS);
				double ang = AngleTo(b.Thing);
				if ( b.Thing.Mass >= LARGE_MASS || b.Thing.bDONTTHRUST ) continue;
				b.Thing.vel.xy += (cos(ang),sin(ang))*12;
				b.Thing.vel.z += 8;
			}
		}
		else
		{
			A_PlaySound("eldrich/tele",CHAN_WEAPON);
			for ( int i=0; i<360; i+=10 )
			{
				let s = Spawn("mkWizDust",pos);
				s.vel.xy = (cos(i),sin(i))*3.0;
				s.scale *= 0.3;
			}
			for ( int i=0; i<64; i++ )
			{
				let s = Spawn("mkWizSprinkles",Vec3Offset(FRandom[EWizFX](-radius,radius),FRandom[EWizFX](-radius,radius),FRandom[EWizFX](0,height)));
				s.scale *= 0.5;
			}
			for ( int i=0; i<8; i++ )
			{
				let s = Spawn("mkWizAfterImage",pos);
				s.scale = scale;
				s.angle = angle;
				s.vel = vel+(FRandom[EWizFX](-2,2),FRandom[EWizFX](-2,2),FRandom[EWizFX](0,1))*0.5;
			}
		}
	}

	double _PitchTo( Actor other )
	{
		if ( !other ) return 0;
		Vector3 otherpos = level.Vec3Diff(Vec3Angle(radius*2,angle,205.),other.Vec3Offset(0,0,other.height/2));
		double dist = otherpos.length();
		if ( dist > 0 ) return -asin(otherpos.z/dist);
		return 0;
	}

	void A_ShootFireball()
	{
		A_FaceTarget(10);
		let s = SpawnMissileXYZ(Vec3Angle(radius*2,angle,missileheight*scale.y),target,"mkAcolyteBoom",false);
		if ( phasetwo )
		{
			s.scale *= 1.5;
			s.args[0] = 2;
		}
		else
		{
			s.args[0] = 4;
			if ( CheckMeleeRange() )
			{
				target.DamageMobj(self,self,Random[AcolyteBoom](10,20),'AcolyteBoom');
				if ( target.Mass >= LARGE_MASS || target.bDONTTHRUST ) return;
				target.vel.xy += Vec2To(target).unit()*12;
				target.vel.z += 4.;
			}
		}
		s.pitch = _PitchTo(target);
		fires++;
	}

	void A_ShootMelee()
	{
		A_FaceTarget(10);
		let s = SpawnMissileXYZ(Vec3Angle(radius*2,angle,missileheight*scale.y),target,"mkAcolyteBoom",false);
		s.pitch = _PitchTo(target);
		if ( CheckMeleeRange() )
		{
			target.DamageMobj(self,self,Random[AcolyteBoom](10,20),'AcolyteBoom');
			if ( target.Mass >= LARGE_MASS || target.bDONTTHRUST ) return;
			target.vel.xy += Vec2To(target).unit()*12;
			target.vel.z += 4.;
		}
	}

	void A_ChargeLaser()
	{
		A_FaceTarget(15);
		let sx = Spawn("mkWizChargePoint",Vec3Angle(radius*2,angle,missileheight*scale.y));
		sx.alpha = lchg/90.;
		lchg++;
		if ( lchg > 50 ) SetState(CurState+1);
	}

	void A_FireLaser()
	{
		if ( lchg&1 ) A_FaceTarget(0.5+(100-lchg)/100.);
		Vector3 spos = Vec3Angle(radius*2,angle,missileheight*scale.y);
		let sx = Spawn("mkWizChargePoint",spos);
		sx.Scale *= 0.5;
		if ( !tracer )
		{
			tracer = Spawn("mkWizBeam",spos);
			tracer.target = self;
		}
		tracer.SetOrigin(spos,true);
		tracer.angle = angle;
		tracer.pitch = lchg*0.7+90;
		mkWizBeam(tracer).A_AdjustBeam();
		lchg--;
		if ( lchg <= 0 ) SetStateLabel("FinishLaser");
	}

	void A_ClearLaser()
	{
		if ( tracer ) tracer.SetStateLabel("Death");
	}

	override bool SpecialBlastHandling( Actor source, double strength )
	{
		return false;
	}

	bool MaxFires( bool secondwave = false )
	{
		int maxcnt = G_SkillPropertyInt(SKILLP_ACSReturn);
		if ( secondwave ) maxcnt += 2;
		if ( phasetwo ) maxcnt /= 2;
		if ( fires >= maxcnt ) return true;
		return false;
	}

	override void Tick()
	{
		vel *= 0;	// don't get pushed
		if ( (Health > 0) && (sprite != GetSpriteIndex('TNT1')) && !Random[EWizAura](0,6) )
		{
			double rad = radius*60.;
			let bi = BlockThingsIterator.Create(self,rad);
			while ( bi.Next() )
			{
				if ( !bi.Thing || !bi.Thing.player || !bi.Thing.IsVisible(self,false) ) continue;
				let c = mkInsanityCounter(bi.Thing.FindInventory("mkInsanityCounter"));
				if ( c && c.special1 ) continue;
				double fact = clamp(rad-Distance3D(bi.Thing),0.,rad)/(rad);
				if ( phasetwo ) bi.Thing.GiveInventory("mkInsanityCounter",int(Random[EWizAura](30,40)*fact));
				else bi.Thing.GiveInventory("mkInsanityCounter",int(Random[EWizAura](20,30)*fact));
			}
		}
		Super.Tick();
	}

	Default
	{
		//$Title Viridescent Lord
		//$Category Marisa/Monsters
		Scale 1.2;
		Health 12000;
		Mass int.max;
		Radius 15;
		Height 90;
		MissileHeight 68.333333;
		MeleeRange 80;
		DamageFactor "AcolyteBoom", 0.0;
		DamageFactor "AcolyteFire", 0.0;
		DamageFactor "Falling", 0.0;
		DamageFactor "Eldrich", 0.0;
		BloodColor "Purple";
		Tag "\cdViridescent Lord\c-";
		Obituary "%o succumbed to the Viridescent Lord.";
		HitObituary "%o got too close to the Viridescent Lord.";
		MONSTER;
		+BUDDHA;
		+BOSS;
		+DONTMORPH;
		+DONTTHRUST;
		+TELESTOMP;
		+NOTARGET;
		+NOINFIGHTING;
		+NOICEDEATH;
		+DONTDRAIN;
		+NOTELEFRAG;
		+LOOKALLAROUND;
		+INTERPOLATEANGLES;
		+DONTHARMSPECIES;
		+NOPAIN;
		+LAXTELEFRAGDMG;	// prevents fall damage completely (thanks, hege)
		Species "Eldrich";
		SeeSound "eldrich/see2";
		AttackSound "eldrich/attack2";
		ActiveSound "eldrich/active2";
		PainSound "eldrich/pain2";
		DeathSound "eldrich/death2";
		DropItem "mkNetherGemDrop";
	}
	States
	{
	Spawn:
		VIRL A 2
		{
			A_LookEx(LOF_NOJUMP,0,0,0,360);
			if ( target )
			{
				if ( phasetwo )
				{
					A_QuakeEx(6,6,6,80,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
					A_PlaySound(SeeSound,CHAN_VOICE,attenuation:ATTN_NONE);
				}
				else A_PlaySound(SeeSound,CHAN_VOICE);
				if ( phasetwo ) mcnt = Random[EWizDecide](35,45);
				else mcnt = Random[EWizDecide](12,16);
				return ResolveState("See");
			}
			return ResolveState(null);
		}
		Wait;
	See:
		VIRL A 2 A_WizCheckMelee();
		Wait;
		VIRL A 0 A_WizDecide();
		Loop;
	SeekingFireball:
		VIRL B 4 A_FaceTarget();
		VIRL C 4
		{
			A_FaceTarget();
			A_PlaySound(AttackSound,CHAN_VOICE);
			fires = 0;
		}
	SeekingFireball2:
		VIRL DDD 4 A_FaceTarget(10);
		VIRL D 4 A_ShootFireball();
		VIRL D 0 A_Jump(64,2);
		VIRL D 0 A_JumpIf(!MaxFires(),"SeekingFireball2");
		VIRL DCBA 3;
		Goto See;
	PhaseTwoStart:
		VIRL A 5 A_JumpIf(last_tele==0,"PhaseTwoBoom");
		VIRL B 20;
		TNT1 A 60 A_TeleIn();
		TNT1 A 0 { last_tele = 0; }
		VIRL B 20 A_TeleOut();
		VIRL A 5;
		Goto PhaseTwoBoom;
	PhaseTwoBoom:
		VIRL A 0
		{
			A_PlaySound(ActiveSound,CHAN_5,attenuation:ATTN_NONE);
			A_PrintBold("\cdYou are persistent, mortal. But this ends now!");
		}
		VIRL AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 2 A_WizMeleePuffs(true);
		VIRL A 0
		{
			A_PlaySound(ActiveSound,CHAN_5,attenuation:ATTN_NONE);
			A_PrintBold("\cdAllow me to show you the full extent of my power!");
		}
		VIRL AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 2 A_WizMeleePuffs(true);
		VIRL A 0 A_PlaySound("eldrich/beamst",CHAN_WEAPON,attenuation:ATTN_NONE);
		VIRL AAAAAAAAAAAAAAAAAA 2 A_WizMeleePuffs(true);
		VIRL A 0 A_PlaySound(AttackSound,CHAN_VOICE);
		VIRL BBBBBBBBBBBBBBBBBB 2 A_WizMeleePuffs(true);
		VIRL B 40
		{
			A_QuakeEx(6,6,6,120,0,2400,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
			A_WizMelee(true);
			Health = mhealth;
			A_SetScale(3.0);
			A_SetSize(30,240);
			SeeSound = "eldrich/see";
			AttackSound = "eldrich/attack";
			ActiveSound = "eldrich/active";
			PainSound = "eldrich/pain";
			DeathSound = "eldrich/death";
			bFULLVOLACTIVE = true;
			bBUDDHA = false;
			phasetwo = true;
			ACS_NamedExecute('LordPhaseTwo');
		}
		VIRL A 20;
		Goto Spawn;
	RadiusBlast:
		VIRL A 5 A_JumpIf(last_tele==0,"RadiusBlast2");
		VIRL B 20;
		TNT1 A 60 A_TeleIn();
		TNT1 A 0 { last_tele = 0; }
		VIRL B 20 A_TeleOut();
		VIRL A 5;
	RadiusBlast2:
		VIRL A 0 A_PlaySound("eldrich/beamst",CHAN_WEAPON,attenuation:ATTN_NONE);
		VIRL AAAAAAAAAAAAAAABBBBBBBBBBBBBBB 2 A_WizMeleePuffs(true);
		VIRL C 0
		{
			A_QuakeEx(6,6,6,80,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
			A_PlaySound(AttackSound,CHAN_VOICE,attenuation:ATTN_NONE);
		}
		VIRL CCCCCCCCCCCC 2 A_WizMeleePuffs(true);
		VIRL D 16
		{
			A_WizMelee(true);
			int cnt = Random[EWizAttack](3,4);
			double ang = FRandom[EWizAttack](0,360);
			for ( int i=0; i<cnt; i++ )
			{
				let s = Spawn("mkSlimeSmoke",Vec3Angle(radius*3,ang+i*(360/cnt),0));
				s.SetZ(s.floorz);
				let s2 = Spawn("mkSlime",s.pos);
				s2.master = self;
				s2.target = target;
				s2.angle = s2.AngleTo(target);
			}
			cnt = Random[EWizAttack](5,8);
			ang = FRandom[EWizAttack](0,360);
			for ( int i=0; i<cnt; i++ )
			{
				let s = Spawn("mkSlimeSmoke",Vec3Angle(radius*5,ang+i*(360/cnt),0));
				s.SetZ(s.floorz);
				let s2 = Spawn("mkSlime",s.pos);
				s2.master = self;
				s2.target = target;
				s2.angle = s2.AngleTo(target);
			}
		}
		VIRL CBA 6;
		Goto See;
	MeleeSmall:
		VIRL B 4 A_FaceTarget();
		VIRL C 4
		{
			A_FaceTarget();
			A_PlaySound(AttackSound,CHAN_VOICE);
			fires = 0;
		}
	MeleeSmall2:
		VIRL DDD 4 A_FaceTarget(10);
		VIRL D 4 A_ShootMelee();
		VIRL D 0 A_JumpIf(target&&(target.Health>0)&&CheckMeleeRange(),"MeleeSmall2");
		VIRL DCBA 3;
		Goto See;
	Melee:
		VIRL AAAAAAAAABBBBBBBBB 2 A_WizMeleePuffs(true);
		VIRL C 0
		{
			A_QuakeEx(6,6,6,80,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
			A_PlaySound(AttackSound,CHAN_VOICE,attenuation:ATTN_NONE);
		}
		VIRL CCCCCCCCC 2 A_WizMeleePuffs(true);
		VIRL D 16 A_WizMelee();
		VIRL CBA 6;
		Goto See;
	CallInMooks:
		VIRL B 16;
		VIRL C 8
		{
			A_QuakeEx(6,6,6,80,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
			A_PlaySound(AttackSound,CHAN_VOICE,attenuation:ATTN_NONE);
		}
		VIRL D 20
		{
			let c = Spawn("mkMookCaller");
			c.target = target;
			c.master = self;
		}
		VIRL CBA 8;
		Goto See;
	CallInSlimes:
		VIRL B 4 A_FaceTarget();
		VIRL C 4
		{
			A_FaceTarget();
			A_PlaySound(AttackSound,CHAN_VOICE);
			fires = 0;
		}
		VIRL DDD 4 A_FaceTarget(10);
		VIRL D 10
		{
			int cnt = Random[EWizAttack](3,4);
			double ang = FRandom[EWizAttack](0,360);
			for ( int i=0; i<cnt; i++ )
			{
				let s = Spawn("mkSlimeSmoke",Vec3Angle(radius*3,ang+i*(360/cnt),0));
				s.SetZ(s.floorz);
				let s2 = Spawn("mkSlime",s.pos);
				s2.master = self;
				s2.target = target;
				s2.angle = ang+i*(360/cnt);
			}
		}
		VIRL CBA 3;
		Goto See;
	Teleport:
		VIRL B 0 { fires = 0; }
	Teleport2:
		VIRL B 20 A_SetTics(phasetwo?20:10);
		TNT1 A 20 A_TeleIn();
		VIRL B 20 A_TeleOut();
		VIRL B 0 A_JumpIf(!phasetwo,"See");
		VIRL B 0 A_JumpIf(MaxFires(),"Teleport3");
		VIRL B 0 A_Jump(80,"Teleport3");
		VIRL C 4
		{
			A_FaceTarget();
			A_QuakeEx(6,6,6,80,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
			A_PlaySound(AttackSound,CHAN_VOICE,attenuation:ATTN_NONE);
			fires = 0;
		}
		VIRL DD 4 A_FaceTarget(10);
		VIRL D 4 A_ShootFireball();
		VIRL DCB 3;
		VIRL A 0 A_JumpIf(MaxFires(),"See");
		VIRL A 0 A_Jump(160,"Teleport2");
		Goto See;
	Teleport3:
		VIRL A 0 A_JumpIf(MaxFires(),2);
		VIRL A 0 A_Jump(160,"Teleport2");
		VIRL A 0 A_Jump(120,"SeekingFireballs");
		VIRL A 0 A_Jump(90,"ChargeLaser");
		Goto See;
	SeekingFireballs:
		VIRL B 8 A_FaceTarget();
		VIRL C 8
		{
			A_FaceTarget();
			A_QuakeEx(6,6,6,80,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
			A_PlaySound(AttackSound,CHAN_VOICE,attenuation:ATTN_NONE);
			fires = 0;
		}
		VIRL DDD 8 A_FaceTarget(10);
		VIRL D 8 A_ShootFireball();
	AnotherFireball1:
		VIRL DD 8 A_FaceTarget(10);
		VIRL D 8 A_ShootFireball();
		VIRL D 0 A_JumpIf(MaxFires(),2);
		VIRL D 0 A_Jump(90,"AnotherFireball1");
	AnotherFireball2:
		VIRL D 8 A_FaceTarget(10);
		VIRL D 8 A_ShootFireball();
		VIRL D 0 A_JumpIf(MaxFires(true),2);
		VIRL D 0 A_Jump(60,"AnotherFireball2");
		VIRL DCBA 6;
		Goto See;
	ChargeLaser:
		VIRL B 8 A_FaceTarget();
		VIRL C 8
		{
			A_QuakeEx(6,6,6,80,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
			A_PlaySound(AttackSound,CHAN_VOICE,attenuation:ATTN_NONE);
		}
		VIRL D 0 A_PlaySound("eldrich/beamst",CHAN_WEAPON,attenuation:ATTN_NONE);
		VIRL D 2 A_ChargeLaser();
		Wait;
		VIRL D 8;
		VIRL D 0
		{
			A_PlaySound("eldrich/beam",CHAN_WEAPON,1.0,true,attenuation:ATTN_NONE);
			A_PlaySound("eldrich/beam",CHAN_ITEM,1.0,true,attenuation:ATTN_NONE);
			A_QuakeEx(9,9,9,80,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
			lchg = 100;
		}
	FiringLaser:
		VIRL D 1 A_FireLaser();
		VIRL D 0 A_FireLaser();
		Goto FiringLaser;
	FinishLaser:
		VIRL D 20
		{
			A_StopSound(CHAN_WEAPON);
			A_StopSound(CHAN_ITEM);
			A_ClearLaser();
		}
		VIRL CBA 6;
		Goto See;
	Death:
		VIRL E 4
		{
			A_KillChildren();
			A_StopSound(CHAN_WEAPON);
			A_StopSound(CHAN_ITEM);
			A_ClearLaser();
			A_PrintBold("\cdNO! THIS CANNOT BE!");
		}
		VIRL E 4 A_DeathFlash();
		VIRL E 20 A_QuakeEx(3,3,3,30,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
		VIRL E 4 A_DeathFlash();
		VIRL E 40 A_QuakeEx(3,3,3,30,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
		VIRL E 4 A_DeathFlash();
		VIRL E 60 A_QuakeEx(3,3,3,30,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
		VIRL F 0
		{
			A_Scream();
			A_PrintBold("\cdNOOOOOOOOOO!!!");
		}
		VIRL F 20
		{
			if ( phasetwo ) A_QuakeEx(9,9,9,180,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
			else A_SetTics(10);
		}
		VIRL GHIJK 20
		{
			if ( !phasetwo ) A_SetTics(10);
		}
		VIRL L -1 A_NoBlocking();
		Stop;
	InIce:
		VIRL Z -1;
		Stop;
	OutOfIce:
		VIRL E 8;
		VIRL E 40
		{
			A_PlaySound(PainSound,CHAN_VOICE);
			A_QuakeEx(3,3,3,20,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:400);
		}
		Goto Spawn;
	}
}

Class mkNetherGemDrop : Actor
{
	void A_DropGem()
	{
		for ( int i=0; i<MAXPLAYERS; i++ )
		{
			if ( !playeringame[i] || !players[i].mo ) continue;
			if ( players[i].mo.FindInventory("mkHubGemNether") ) return;
		}
		let a = A_DropItem("mkHubGemNether");
		a.TossItem();
		if ( level.mapname == 'MARISA' )
		{
			a.special = ACS_Execute;
			a.args[0] = -int('Gottem');
		}
	}

	Default
	{
		+NOGRAVITY;
		+NOBLOCKMAP;
		+DONTSPLASH;
	}

	States
	{
	Spawn:
		TNT1 A 10;
		TNT1 A 1 A_DropGem();
		Stop;
	}
}

Class mkWizAfterimage : Actor
{
	Default
	{
		RenderStyle "Translucent";
		Alpha 0.5;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	States
	{
	Spawn:
		VIRL B 1 A_FadeOut(0.02);
		Wait;
	}
}

Class mkMookCaller : Actor
{
	const SPOT_TID = 13000;
	const DOOR_TAG = 1300;
	const DOORIN_TAG = 1301;

	Array<Actor> AcolyteSpots;
	Array<int> AcolyteDoors, AcolyteDoorInsides;

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		// populate arrays
		ActorIterator t = ActorIterator.Create(SPOT_TID);
		Actor a;
		while ( a = t.Next() ) AcolyteSpots.Push(a);
		SectorTagIterator s = SectorTagIterator.Create(DOOR_TAG);
		int i;
		while ( (i = s.Next()) != -1 ) AcolyteDoors.Push(i);
		s = SectorTagIterator.Create(DOORIN_TAG);
		while ( (i = s.Next()) != -1 ) AcolyteDoorInsides.Push(i);
		if ( (AcolyteSpots.Size() <= 0) || (AcolyteDoors.Size() <= 0) || (AcolyteDoorInsides.Size() <= 0) )
			Destroy();
	}

	void A_WaitDoor( bool close = false )
	{
		for ( int i=0; i<AcolyteDoors.Size(); i++ )
		{
			int d = AcolyteDoors[i];
			// if closing, crush anything that's in the way
			if ( close )
			{
				for ( Actor a=level.Sectors[d].thinglist; a; a=a.snext )
					a.DamageMobj(null,null,50,'Crush',DMG_THRUSTLESS|DMG_FORCED);
			}
			if ( level.Sectors[d].CeilingData ) return;
		}
		SetState(CurState+1);
	}

	void A_CloseDoor()
	{
		level.ExecuteSpecial(Door_Close,self,null,false,DOOR_TAG,32);
	}

	void A_OpenDoor()
	{
		level.ExecuteSpecial(Door_Open,self,null,false,DOOR_TAG,32);
	}

	void A_CallAcolytes()
	{
		for ( int i=0; i<AcolyteSpots.Size(); i++ )
		{
			let t = Spawn("mkElderAcolyte",AcolyteSpots[i].pos);
			t.angle = AcolyteSpots[i].angle;
			t.target = target;
			t.vel.xy = (cos(t.angle),sin(t.angle))*15.;
			t.master = master;
			if ( master.Health <= 0 )
				t.DamageMobj(null,null,int.max,'Massacre',DMG_FORCED|DMG_THRUSTLESS);
		}
	}

	void A_ClearInside()
	{
		for ( int i=0; i<AcolyteDoorInsides.Size(); i++ )
		{
			for ( Actor a=level.Sectors[AcolyteDoorInsides[i]].thinglist; a; a=a.snext )
			{
				if ( a.player ) a.DamageMobj(null,null,int.max,'Crush',DMG_THRUSTLESS|DMG_FORCED);
				else
				{
					a.ClearCounters();
					a.Destroy();
				}
			}
		}
	}

	Default
	{
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}

	States
	{
	Spawn:
		TNT1 A 1 A_WaitDoor();
		Wait;
		TNT1 A 0 A_CloseDoor();
		TNT1 A 1 A_WaitDoor(true);
		Wait;
		TNT1 A 1 A_OpenDoor();
		TNT1 A 1 A_WaitDoor();
		TNT1 A 120 A_CallAcolytes();
		TNT1 A 0 A_CloseDoor();
		TNT1 A 1 A_WaitDoor(true);
		Wait;
		TNT1 A 1 A_ClearInside();
		Stop;
	}
}

Class mkRisingMeleePoof : Actor
{
	Default
	{
		RenderStyle "Add";
		Alpha 0.2;
		Scale 2.0;
		Radius 2;
		Height 2;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
		+FORCEXYBILLBOARD;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		SetState(FindState("Spawn")+Random[EWizPoof](0,6));
	}
	States
	{
	Spawn:
		FSFX NOPQRST 2 Bright
		{
			A_FadeOut(0.01);
			vel.xy *= 0.98;
			vel.z += 0.04;
		}
		Loop;
	}
}

Class mkWizSprinkles : Actor
{
	int tcnt;
	Default
	{
		RenderStyle "Add";
		Translation "0:255=%[0.00,0.00,0.00]:[0.74,1.51,0.64]";
		Radius 2;
		Height 2;
		Scale 1.2;
		+MISSILE;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+THRUACTORS;
		+DONTSPLASH;
		+FORCEXYBILLBOARD;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		frame = Random[EWizFX](0,4);
	}
	States
	{
	Spawn:
		TLGL # 1 BRIGHT
		{
			tcnt++;
			if ( !(tcnt%3) ) frame++;
			if ( frame > 4 ) frame = 0;
			vel += (FRandom[EWizFX](-1,1),FRandom[EWizFX](-1,1),FRandom[EWizFX](-1,1))*FRandom[EWizFX](0.1,0.2);
			A_FadeOut(0.02);
		}
		Wait;
	Death:
		TLGL # 1
		{
			tcnt++;
			if ( !(tcnt%3) ) frame++;
			if ( frame > 4 ) frame = 0;
			A_FadeOut(0.2);
		}
		Wait;
	}
}

Class mkWizChargePoint : Actor
{
	Default
	{
		RenderStyle "Add";
		Translation "0:255=%[0.00,0.00,0.00]:[0.74,1.51,0.64]";
		Radius 2;
		Height 2;
		Scale 1.5;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
		+FORCEXYBILLBOARD;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		double ang, pt;
		ang = FRandom[Puff](0,360);
		pt = FRandom[Puff](-90,90);
		vel = (cos(pt)*cos(ang),cos(pt)*sin(ang),-sin(pt))*FRandom[Puff](1.6,3.2);
	}
	States
	{
	Spawn:
		ICPR DEFGH 3 Bright;
		Stop;
	}
}

Class mkWizMeleeBlast : Actor
{
	Default
	{
		RenderStyle "Add";
		Translation "231:239=187:202";
		Scale 2.0;
		Radius 8;
		Height 4;
		Speed 10;
		+NOBLOCKMAP;
		+DONTSPLASH;
		+MISSILE;
		+STEPMISSILE;
		+THRUACTORS;
		+NOEXPLODEFLOOR;
	}
	override void Tick()
	{
		Super.Tick();
		if ( level.frozen || globalfreeze ) return;
		SetZ(floorz);
		int dst = special1?150:90;
		let b = BlockThingsIterator.Create(self,dst);
		while ( b.Next() )
		{
			if ( !b.Thing || (target && (b.Thing.Species == target.Species)) || !b.Thing.bSHOOTABLE || (b.Thing.Health <= 0) || (b.Thing == target) || (Distance3D(b.Thing) > dst) ) continue;
			b.Thing.DamageMobj(self,target,special1?1:8,'Melee',DMG_THRUSTLESS);
			if ( b.Thing.Mass >= LARGE_MASS || b.Thing.bDONTTHRUST ) continue;
			b.Thing.vel += vel*(special1?0.05:0.2);
			b.Thing.vel.z += (special1?0.3:2.);
		}
	}
	States
	{
	Spawn:
	Death:
		SBS4 D 3 Bright;
		SBS4 E 4 Bright;
		SBS4 F 5 Bright;
		SBS4 G 6 Bright;
		SBS4 H 7 Bright;
		Stop;
	}
}

Class mkWizDust : Actor
{
	Default
	{
		RenderStyle "Translucent";
		Radius 8;
		Height 2;
		Alpha 0.5;
		Scale 1.5;
		+NOBLOCKMAP;
		+DONTSPLASH;
		+MISSILE;
		+STEPMISSILE;
		+THRUACTORS;
		+NOEXPLODEFLOOR;
	}
	States
	{
	Spawn:
		SDST A 1
		{
			SetZ(floorz);
			A_FadeOut(0.02);
			A_SetScale(scale.x*1.01,scale.y*0.99);
		}
		Wait;
	Death:
		SDST A 1
		{
			SetZ(floorz);
			A_FadeOut(0.06);
			A_SetScale(scale.x*1.01,scale.y*0.99);
		}
		Wait;
	}
}

Class mkWizBeamTracer : LineTracer
{
	Actor ignoreme;
	Array<Actor> hitlist;

	override ETraceStatus TraceCallback()
	{
		if ( Results.HitType == TRACE_HitActor )
		{
			if ( Results.HitActor == ignoreme ) return TRACE_Skip;
			if ( Results.HitActor.bSHOOTABLE ) hitlist.Push(Results.HitActor);
			return TRACE_Skip;
		}
		else if ( (Results.HitType == TRACE_HitWall) && (Results.Tier == TIER_Middle) )
		{
			if ( !Results.HitLine.sidedef[1] || (Results.HitLine.Flags&(Line.ML_BlockHitscan|Line.ML_BlockEverything)) )
				return TRACE_Stop;
			return TRACE_Skip;
		}
		return TRACE_Stop;
	}
}

Class mkWizBeam : Actor
{
	transient mkWizBeamTracer t;
	Vector3 lasthit;
	Array<Actor> booms;
	int bpos;
	Default
	{
		RenderStyle "Add";
		Radius 0;
		Height 0.1;
		RenderRadius 8000;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
		+INTERPOLATEANGLES;
	}
	void A_AdjustBeam()
	{
		if ( !t ) t = new("mkWizBeamTracer");
		t.ignoreme = target;
		t.hitlist.Clear();
		t.Trace(pos,CurSector,(cos(angle)*cos(pitch-90),sin(angle)*cos(pitch-90),-sin(pitch-90)),8000,0);
		for ( int i=0; i<t.hitlist.Size(); i++ )
			t.hitlist[i].DamageMobj(self,target,10,'Railgun',DMG_THRUSTLESS);
		A_SetScale(2.,t.Results.Distance);
		if ( level.Vec3Diff(t.Results.HitPos,lasthit).length() > 12 )
		{
			let s = Spawn("mkWizDelayBoom",t.Results.HitPos-t.Results.HitVector*4);
			s.target = target;
			lasthit = t.Results.HitPos;
			booms.Push(s);
		}
	}
	void A_DetonateBooms()
	{
		for ( int i=0; i<5; i++ )
		{
			if ( bpos >= booms.Size() )
			{
				Destroy();
				return;
			}
			if ( i == 2 ) booms[bpos].SetStateLabel("Death");
			else booms[bpos].Destroy();
			bpos++;
		}
	}
	States
	{
	Spawn:
		PRKM A -1;
		Stop;
	Death:
		PRKM A 1 A_FadeOut(0.1,0);
		PRKM A 0 A_JumpIf(alpha<=0,1);
		Loop;
		TNT1 A 2 A_DetonateBooms();
		Wait;
	}
}

Class mkWizDelayBoom : Actor
{
	Default
	{
		RenderStyle "Add";
		Translation "0:255=%[0.00,0.00,0.00]:[0.74,1.51,0.64]";
		Scale 1.6;
		Radius 0;
		Height 0.1;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
		+FORCEYBILLBOARD;
		+EXTREMEDEATH;
	}
	void A_SplodeUp( int dmg, double rad )
	{
		let b = BlockThingsIterator.Create(self,rad);
		while ( b.Next() )
		{
			if ( !b.Thing || !b.Thing.bSHOOTABLE || (b.Thing.Health <= 0) || (b.Thing == target) || (Distance2D(b.Thing) > rad) ) continue;
			double dfact = 1.-(Distance2D(b.Thing)/rad);
			b.Thing.DamageMobj(self,target,int(dmg*dfact),'Explosion',DMG_THRUSTLESS);
			double ang = AngleTo(b.Thing);
			if ( b.Thing.Mass >= LARGE_MASS || b.Thing.bDONTTHRUST ) continue;
			b.Thing.vel.xy += (cos(ang),sin(ang))*8*dfact;
			b.Thing.vel.z += 12*dfact;
		}
	}
	States
	{
	Spawn:
		FX13 ABCDEFGH 2 Bright;
		TNT1 A -1;
		Stop;
	Death:
		MSP1 H 3 Bright
		{
			A_SetScale(3.0,4.5);
			A_PlaySound("SorcererBigBallExplode");
			A_SetTics(Random[EWizFX](1,3));
			A_SplodeUp(40,200);
		}
		MSP1 IJK 3 Bright A_SplodeUp(15,120);
		MSP1 LMNOP 3 Bright;
		Stop;
	}
}

Class mkInsanityMeter : HUDMessageBase
{
	TextureID meterbase, metericon, meterbar;
	double alpha;
	Inventory cnt;
	DynamicValueInterpolator isan;
	int grace;

	mkInsanityMeter Init()
	{
		meterbase = TexMan.CheckForTexture("emeter_m",TexMan.Type_Any);
		metericon = TexMan.CheckForTexture("emeter_i",TexMan.Type_Any);
		meterbar = TexMan.CheckForTexture("emeter_b",TexMan.Type_Any);
		alpha = 1.0;
		isan = DynamicValueInterpolator.Create(0,0.25,1,8);
		return self;
	}

	override bool Tick()
	{
		cnt = players[consoleplayer].camera.FindInventory("mkInsanityCounter");
		if ( !cnt || (cnt.amount <= 0) )
		{
			grace++;
			if ( grace > 50 )
				alpha -= 0.05;
		}
		else
		{
			grace = 0;
			isan.update(cnt.amount);
			alpha = 1.0;
		}
		return (alpha<=0);
	}

	override void Draw( int bottom, int visibility )
	{
		Vector2 hscale = StatusBar.GetHudScale();
		Vector2 vsize = (Screen.GetWidth()/hscale.x,Screen.GetHeight()/hscale.y);
		Vector2 bs = TexMan.GetScaledSize(meterbar);
		Vector2 pos = (vsize.x-(bs.x+8),(bottom*0.5)/hscale.y-bs.y/2);
		Screen.DrawTexture(meterbase,false,pos.x,pos.y,DTA_VirtualWidthF,vsize.x,DTA_VirtualHeightF,vsize.y,DTA_KeepRatio,true,DTA_Alpha,alpha);
		if ( !cnt ) return;
		if ( cnt.special1 )
			Screen.DrawTexture(metericon,false,pos.x,pos.y,DTA_VirtualWidthF,vsize.x,DTA_VirtualHeightF,vsize.y,DTA_KeepRatio,true,DTA_Alpha,alpha);
		int ct = int((pos.y+(cnt.maxamount-clamp(cnt.amount,0,cnt.maxamount))*(bs.y/cnt.maxamount))*hscale.y);
		Screen.DrawTexture(meterbar,false,pos.x,pos.y,DTA_VirtualWidthF,vsize.x,DTA_VirtualHeightF,vsize.y,DTA_KeepRatio,true,DTA_Alpha,alpha,DTA_ClipTop,ct);
	}
}

// handler for "Eldrich" damage type, builds up an "insanity" debuff
Class mkEldrichHandler : EventHandler
{
	ui mkInsanityMeter meter;

	override void PostUiTick()
	{
		let cnt = players[consoleplayer].camera.FindInventory("mkInsanityCounter");
		if ( !cnt || (cnt.amount <= 0) ) return;
		if ( !meter )
		{
			meter = new("mkInsanityMeter").Init();
			statusbar.AttachMessage(meter);
		}
	}

	override void WorldThingDamaged( WorldEvent e )
	{
		if ( !e.Thing.player ) return;
		if ( e.DamageType == 'Eldrich' )
		{
			mkInsanityCounter cnt = mkInsanityCounter(e.Thing.FindInventory("mkInsanityCounter"));
			if ( !cnt ) e.Thing.GiveInventory("mkInsanityCounter",e.Damage*40*Random[Insane](3,5));
			else if ( cnt.special1 )
			{
				if ( e.DamageSource ) cnt.Amount = min(cnt.MaxAmount,cnt.Amount+e.Damage*30*Random[Insane](3,5));
				else cnt.Amount = min(cnt.MaxAmount,cnt.Amount+e.Damage*3*Random[Insane](3,5));
			}
			else cnt.Amount = min(cnt.MaxAmount,cnt.Amount+e.Damage*40*Random[Insane](3,5));
		}
		else if ( (e.DamageSource is 'mkElderWizard') || (e.DamageSource is 'mkElderAcolyte') )
		{
			mkInsanityCounter cnt = mkInsanityCounter(e.Thing.FindInventory("mkInsanityCounter"));
			if ( !cnt ) e.Thing.GiveInventory("mkInsanityCounter",e.Damage*10*Random[Insane](3,5));
			else if ( cnt.special1 ) cnt.Amount = min(cnt.MaxAmount,cnt.Amount+e.Damage*3*Random[Insane](3,5));
			else cnt.Amount = min(cnt.MaxAmount,cnt.Amount+e.Damage*10*Random[Insane](3,5));
		}
	}

	override void PlayerRespawned( PlayerEvent e )
	{
		if ( players[e.playernumber].mo )
		{
			let cnt = players[e.playernumber].mo.FindInventory("mkInsanityCounter");
			if ( cnt ) cnt.amount = 0;
		}
	}

	override void WorldLoaded( WorldEvent e )
	{
		// "pre-cache" shader
		Shader.SetEnabled(players[consoleplayer],"insanity1",true);
		Shader.SetEnabled(players[consoleplayer],"insanity2",true);
		Shader.SetEnabled(players[consoleplayer],"insanity1",false);
		Shader.SetEnabled(players[consoleplayer],"insanity2",false);
	}

	override void RenderOverlay( RenderEvent e )
	{
		let cnt = e.Camera.FindInventory("mkInsanityCounter");
		if ( cnt && (cnt.amount > 0) )
		{
			Shader.SetEnabled(players[consoleplayer],"insanity1",true);
			Shader.SetEnabled(players[consoleplayer],"insanity2",true);
			if ( cnt.special1 )
			{
				Shader.SetUniform1f(players[consoleplayer],"insanity1","dfact",clamp(cnt.amount*0.00075-0.3,0.0,1.0));
				Shader.SetUniform1f(players[consoleplayer],"insanity2","dfact",clamp(cnt.amount*0.00075-0.3,0.0,1.0));
				Shader.SetUniform1f(players[consoleplayer],"insanity2","tun",clamp(cnt.amount*0.001-1.0,0.0,0.8));
			}
			else
			{
				Shader.SetUniform1f(players[consoleplayer],"insanity1","dfact",clamp(cnt.amount*0.00075-0.9,0.0,1.0));
				Shader.SetUniform1f(players[consoleplayer],"insanity2","dfact",clamp(cnt.amount*0.00075-0.9,0.0,1.0));
				Shader.SetUniform1f(players[consoleplayer],"insanity2","tun",clamp(cnt.amount*0.0025-4.0,0.0,0.8));
			}
			Shader.SetUniform1f(players[consoleplayer],"insanity1","timer",(gametic+e.Fractic)/35.);
			Shader.SetUniform1f(players[consoleplayer],"insanity2","timer",(gametic+e.Fractic)/35.);
		}
		else
		{
			Shader.SetEnabled(players[consoleplayer],"insanity1",false);
			Shader.SetEnabled(players[consoleplayer],"insanity2",false);
		}
	}
}

Class mkInsanityCounter : Inventory
{
	Default
	{
		+INVENTORY.UNDROPPABLE;
		+INVENTORY.UNTOSSABLE;
		+INVENTORY.KEEPDEPLETED;
		Inventory.MaxAmount 2000;
		Tag "Insanity";
	}
	override void DoEffect()
	{
		Super.DoEffect();
		if ( !owner || (amount <= 0) ) return;
		if ( !tracer )
		{
			tracer = Spawn("mkInsanitySound");
			tracer.target = owner;
			tracer.master = self;
		}
		if ( special1 )
		{
			owner.A_SetAngle(owner.angle+sin(level.time*1.4325)*0.000234346*min(amount,1000),SPF_INTERPOLATE);
			owner.A_SetPitch(owner.pitch+sin(level.time*1.6346)*0.000243457*min(amount,1000),SPF_INTERPOLATE);
		}
		if ( !(level.time%4) && !Random[Insane](0,3) )
		{
			owner.A_SetAngle(owner.angle+cos(level.time*8.4325)*0.000434346*amount,SPF_INTERPOLATE);
			owner.A_SetPitch(owner.pitch+cos(level.time*8.6346)*0.000443457*amount,SPF_INTERPOLATE);
			if ( special1 && !Random[Insane](0,2) && (Random[Insane](0,amount/10) > 20) )
				owner.DamageMobj(null,null,int(amount*0.002*FRandom[Insane](0.2,1.2)),'Eldrich',DMG_THRUSTLESS|DMG_NO_PAIN);
		}
		if ( amount >= maxamount )
		{
			if ( !special1 && (owner == players[consoleplayer].mo) )
				Console.Printf("You have taken critical sanity damage.");
			special1 = 1;
		}
		if ( owner.Health <= 0 ) amount -= max(3,8-amount/400);
		else if ( special1 ) amount -= max(1,12-amount/150);
		else amount -= max(2,6-amount/350);
		if ( amount <= 0 )
		{
			if ( special1  && (owner == players[consoleplayer].mo) )
				Console.Printf("Your head feels clear.");
			special1 = 0;
			amount = 0;
		}
	}
}

Class mkInsanitySound : Actor
{
	Default
	{
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		A_PlaySound("insanity/layer1",CHAN_5,0.01,true,ATTN_NONE);
		A_PlaySound("insanity/layer2",CHAN_6,0.01,true,ATTN_NONE);
		A_PlaySound("insanity/layer3",CHAN_7,0.01,true,ATTN_NONE);
	}
	override void Tick()
	{
		Super.Tick();
		if ( !target || !master )
		{
			A_StopSound(CHAN_5);
			A_StopSound(CHAN_6);
			A_StopSound(CHAN_7);
			Destroy();
			return;
		}
		SetOrigin(target.pos,true);
		if ( (players[consoleplayer].camera != target) || (Inventory(master).amount <= 0) )
		{
			A_SoundVolume(CHAN_5,0.);
			A_SoundVolume(CHAN_6,0.);
			A_SoundVolume(CHAN_7,0.);
		}
		else if ( master.special1 )
		{
			A_SoundVolume(CHAN_5,clamp(Inventory(master).Amount*0.0005,0.0,0.4));
			A_SoundVolume(CHAN_6,clamp(Inventory(master).Amount*0.00075-0.3,0.0,0.6));
			A_SoundVolume(CHAN_7,clamp(Inventory(master).Amount*0.001-1.0,0.0,1.0));
		}
		else
		{
			A_SoundVolume(CHAN_5,clamp(Inventory(master).Amount*0.0005,0.0,0.4));
			A_SoundVolume(CHAN_6,clamp(Inventory(master).Amount*0.00075-0.9,0.0,0.6));
			A_SoundVolume(CHAN_7,clamp(Inventory(master).Amount*0.0025-4.0,0.0,1.0));
		}
	}
}

Class mkSlimeGas : Actor
{
	Default
	{
		RenderStyle "Translucent";
		Radius 2;
		Height 2;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
		+FORCEXYBILLBOARD;
		+THRUACTORS;
		Scale 1.8;
		Alpha 0.5;
		Translation "0:255=%[0.00,0.00,0.00]:[0.80,2.00,0.80]";
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		double ang, pt;
		scale *= FRandom[Puff](0.5,1.0);
		alpha *= FRandom[Puff](0.5,1.0);
		ang = FRandom[Puff](0,360);
		pt = FRandom[Puff](-90,90);
		vel += (cos(pt)*cos(ang),cos(pt)*sin(ang),-sin(pt))*FRandom[Puff](0.2,0.8);
	}
	States
	{
	Spawn:
		SPIR QQRRSSTTUU 2 { vel *= 0.95; }
		Stop;
	}
}

Class mkSlimeSmoke : Actor
{
	Default
	{
		Scale 0.8;
		Translation "0:255=%[0.00,0.00,0.00]:[0.80,2.00,0.80]";
	}
	States
	{
	Spawn:
		MNSM ABCDEFGHIJKLMNOPQ 1 Bright;
		Stop;
	}
}

// Slimes - pretty similar to Unreal's bloblets
// slide themselves towards a target and deal damage by coughing up gas
// can cause sanity damage too since they're pretty much full of Elder Fluid
Class mkSlime : Actor
{
	Vector2 refscale;
	double phase, freq, flatten;
	int slimecooldown;
	bool checkcol;

	Default
	{
		//$Title Slime
		//$Sprite SLIMA0
		//$Category Marisa/Monsters
		RenderStyle "Translucent";
		Scale 1.2;
		Alpha 0.95;
		Health 60;
		Radius 25;
		Height 20;
		Speed 4;
		PainChance 255;
		MeleeRange 50;
		MONSTER;
		BloodColor "40 FF 40";
		+THRUSPECIES;
		+DONTMORPH;
		+QUICKTORETALIATE;
		+DONTHARMSPECIES;
		+LOOKALLAROUND;
		-COUNTKILL;
		Species "Eldrich";
		PainSound "slime/pain";
		DeathSound "slime/death";
		Obituary "%o was corroded by a Slime.";
		Tag "Slime";
		DamageFactor "AcolyteBoom", 0.0;
		DamageFactor "AcolyteFire", 0.0;
		DamageFactor "Falling", 0.0;
		DamageFactor "Eldrich", 0.0;
		// have to build in the translation because SLADE decided to be a piece of shit and won't let me remap the png
		Translation "4:32=187:201", "255:255=202:202", "33:50=188:201";
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		Health -= Random[Slime](0,40);
		speed *= Frandom[Slime](0.9,1.3);
		refscale = scale*FRandom[Slime](0.9,1.35);
		scale.x *= 1.3;
		phase = FRandom[Slime](0.0,1.0);
		freq = (4.0+FRandom[Slime](-1.3,1.3))*RandomPick[Slime](-1,1);
		A_PlaySound(String.Format("slime/active%d",RandomPick[Slime](1,3)),CHAN_7,0.03,true,8.0);
	}
	override void OnDestroy()
	{
		Super.OnDestroy();
		A_StopSound(CHAN_7);
	}
	override bool CanCollideWith( Actor other, bool passive )
	{
		if ( other == target ) return checkcol;
		else if ( other.player || other.bIsMonster ) return false;
		return true;
	}
	override void Tick()
	{
		Super.Tick();
		if ( Health <= 0 )
		{
			phase += freq*0.01;
			A_SoundVolume(CHAN_7,0.01);
		}
		else if ( target )
		{
			phase += freq*2.5;
			A_SoundVolume(CHAN_7,0.12);
		}
		else
		{
			phase += freq;
			A_SoundVolume(CHAN_7,0.03);
		}
		// wiggle wiggle
		scale.x = refscale.x+sin(phase)*refscale.x*0.3;
		scale.y = refscale.y+cos(phase)*refscale.y*0.15;
		scale.x += flatten*refscale.x;
		scale.y -= flatten*refscale.y;
		flatten = max(0.,flatten-0.04);
	}
	void A_SlimeAttack()
	{
		slimecooldown = Random[Slime](20,35);
		A_FaceTarget();
		A_SetTics(Random[Slime](3,12));
		A_PlaySound("slime/attack",CHAN_VOICE);
		int sang = Random[Slime](0,360);
		for ( int i=0; i<10; i++ )
		{
			let s = Spawn("mkSlimeGas",Vec3Angle(5*refscale.x,sang+i*36.,4.));
			s.target = self;
			s.angle = sang+i*36;
			s.vel = (cos(s.angle),sin(s.angle),0)*FRandom[Slime](3.,4.);
		}
		let bt = BlockThingsIterator.Create(self,80);
		while ( bt.Next() )
		{
			let t = bt.Thing;
			if ( !t || (t.species == species) || (t == master) || (Distance3D(t) > (t.radius+80)) ) continue;
			t.DamageMobj(self,self,Random[Slime](1,2),'Slime');
			if ( t.player ) t.GiveInventory("mkInsanityCounter",Random[Slime](70,120));
		}
	}
	// turns out it can not be blocking
	bool BlockingLineIsBlocking()
	{
		if ( !BlockingLine ) return false;
		// one-sided
		if ( !BlockingLine.sidedef[1] ) return true;
		// blocks us
		if ( BlockingLine.flags&(Line.ML_BLOCKING|Line.ML_BLOCKMONSTERS|Line.ML_BLOCKEVERYTHING) ) return true;
		return false;
	}
	void A_SlimeChase()
	{
		if ( !target || (target.Health <= 0) )
		{
			SetStateLabel("Spawn");
			return;
		}
		Vector2 dir = RotateVector((radius,0),AngleTo(target));
		Vector3 oldpos = pos;
		bool success = false;
		checkcol = true;
		for ( int i=0; i<20; i++ )
		{
			if ( TryMove(Vec2Offset(dir.x,dir.y),int(maxdropoffheight)) )
				continue;
			if ( BlockingMobj == target )
			{
				success = true;
				break;
			}
			if ( BlockingLineIsBlocking() || (BlockingMobj && BlockingMobj.bSOLID) )
				break;
		}
		checkcol = false;
		SetOrigin(oldpos,false);
		if ( success )
		{
			A_FaceTarget(10);
			dir = RotateVector((speed,0),angle);
			TryMove(Vec2Offset(dir.x,dir.y),int(maxdropoffheight));
		}
		else A_Chase(null,null);
	}
	States
	{
	Spawn:
		SLIM A 1 A_Look();
		Wait;
	See:
		SLIM A 1
		{
			if ( Health <= 0 ) return ResolveState("Death");	// somehow I have to do this
			A_SlimeChase();
			slimecooldown = max(0,slimecooldown-1);
			return A_JumpIf(CheckMeleeRange()&&!Random[Slime](0,8)&&(slimecooldown<=0),"Melee");
		}
		Wait;
	Melee:
		SLIM A 1 A_SlimeAttack();
		Goto See;
	Pain:
		SLIM A 1
		{
			flatten = FRandom[Slime](0.5,0.7);
			A_FaceTarget();
			A_Recoil(FRandom[Slime](2.3,3.3));
			A_Pain();
			A_SetTics(Random[Slime](3,12));
		}
		Goto See;
	Death:
		SLIM A 0
		{
			flatten = FRandom[Slime](0.8,0.9);
			A_ScreamAndUnblock();
		}
		SLIM A 1 A_JumpIf(flatten<=0.5,1);
		Wait;
		SLIM A 1
		{
			refscale.x *= 1.0001;
			refscale.y *= 0.99;
			A_FadeOut(0.003);
			return A_JumpIf(refscale.y<0.1,1);
		}
		Wait;
		SLIM A 1 A_FadeOut(0.03);
		Wait;
	}
}
